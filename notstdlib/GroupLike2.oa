module Data.GroupLike has (
    GroupLike,
    Total, Associative, HasIdentity, Invertible, Commutative
) where (
    #-- ok now = is unify, := or <- is assign
    GroupLike : Type -> Constraint;
    GroupLike a = (
        #-- TODO: naming
        #-- this assumes it is total. if not it is a -> a -> b
        operate : a -> a -> a
    );
    
    Total : Type -> Constraint;
    Total a = GroupLike a => (
        total : forall x : a, y : a istrue (operate x y) : a
    );
    
    #-- NOTE: Associative a implies Alternative a however not sure how to show this
    #-- then Alternative is specified in a file depending on this one
    #-- for now i'll introduce a new constraint i guess
    Associative : Type -> Constraint;
    Associative a = GroupLike a => (
        associative : forall x : a, y : a, z : a istrue (operate x (operate y z)) = (operate (operate x y) z)
    );
    
    HasIdentity : Type -> Constraint;
    HasIdentity a = GroupLike a => (
        identity : a
    );
    
    Invertible : Type -> Constraint;
    Invertible a = GroupLike a => (
        invert : a -> a;
        invertible : forall a : a istrue (conjoin
            (a = (operate (operate a (invert a)) a))
            (invert a = (operate (operate (invert a) a) (invert a)))
        )
    );
    
    Closed : Type -> Constraint;
    Closed = Total;
    
    #-- TODO: typeclass isn't a type so it doesn't make sense for function declaration
    #-- especially function declaration inside a typeclass
    Semigroupoid : Type -> Constraint;
    Semigroupoid a = Associative a => ();
    SmallCategory : Type -> Constraint;
    SmallCategory a = Semigroupoid a, HasIdentity a => ();
    Groupoid : Type -> Constraint;
    Groupoid a = SmallCategory a, Invertible a => ();
    
    Magma : Type -> Constraint;
    Magma a = Total a => ();
    Quasigroup : Type -> Constraint;
    Quasigroup a = Magma a, Invertible a => ();
    UnitalMagma : Type -> Constraint;
    UnitalMagma a = Magma a, HasIdentity a => ();
    Loop : Type -> Constraint;
    Loop a = Quasigroup a, UnitalMagma a => ();
    
    Semigroup : Type -> Constraint;
    Semigroup a = Semigroupoid a, Quasigroup a => ();
    InverseSemigroup : Type -> Constraint;
    InverseSemigroup a = Semigroup a, Invertible a => ();
    Monoid : Type -> Constraint;
    Monoid a : SmallCategory a, UnitalMagma a, Semigroup a => ();
    CommutativeMonoid : Type -> Constraint;
    CommutativeMonoid a : Monoid a, Commutative a => ();
    Group : Type -> Constraint;
    Group a : Groupoid a, Quasigroup a, Loop a, InverseSemigroup a, Monoid a => ();
    AbelianGroup : Type -> Constraint;
    AbelianGroup a : Group a, CommutativeMonoid a, Commutative a => ()
)